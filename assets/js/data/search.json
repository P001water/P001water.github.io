[
  
  {
    "title": "BurpSuite Pro 2022.8和练手写的一个小工具",
    "url": "/posts/BurpSuite-Pro-2022.8%E5%92%8C%E7%BB%83%E6%89%8B%E5%86%99%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7/",
    "categories": "瞎折腾, BurpSuite",
    "tags": "Burp",
    "date": "2022-12-01 00:00:00 +0800",
    





    
    "snippet": "文前漫谈没啥别的想法，纯粹想更新一下了。我有个毛病，软件和工具总是喜欢最新的，所以刚接触java的时候我的java环境配的就是当时刚出的JDK-17。于是现在我需要为我的这个毛病付出一点代价：）BP的也由于更新的缘故，记不清从哪个版本开始，注册机也更新了，虽然从我们的角度还是那个熟悉的页面，还是那个熟悉的By h3110w0r1d，但是用旧注册机好像已经不能注册新版本了。BurpSuite ...",
    "content": "文前漫谈没啥别的想法，纯粹想更新一下了。我有个毛病，软件和工具总是喜欢最新的，所以刚接触java的时候我的java环境配的就是当时刚出的JDK-17。于是现在我需要为我的这个毛病付出一点代价：）BP的也由于更新的缘故，记不清从哪个版本开始，注册机也更新了，虽然从我们的角度还是那个熟悉的页面，还是那个熟悉的By h3110w0r1d，但是用旧注册机好像已经不能注册新版本了。BurpSuite Pro 2022.8为了方便，直接内嵌了一个jdk17了，整个内容就像这样，bat脚本启动会有cmd窗口（黑窗口），用vbs脚本启动就OK，ico是图标文件，有那点外观要求的能用上，such as me。BurpLoaderKeygen就是新版注册机，h3110w0r1d出品，burpsuite_pro_v2022.8.4就是官网下的burp主要文件  下载地址：  Burpsuite_v2022.8即开即用版.ziprunburp.batset JAVA_HOME=jdk-17.0.2set Path=%JAVA_HOME%\\bin;\tjava -javaagent:BurpLoaderKeygen.jar -noverify -jar burpsuite_pro_v2022.8.4.jarset 设置临时环境变量，这里就是本目录下的文件夹jdk-17.0.2 ，然后同样把\\bin目录装进环境变量，然后就是java运行的一些选项runburp.vbsSet ws = CreateObject(\"Wscript.Shell\") ws.run \"cmd /c runburp.bat\",vbhide vbs不会不说了另一个小工具因为刚开始用是jdk17，现在接触的很多jar文件又需要jdk8的（就是java 1.8）于是需求就来了，我想像运行burp一样，直接一个vbs脚本启动，还可以自定义图标的（这是怪病）其实复制粘贴也花费不了几个时间，巧的是最近正好有开发gui的需求，正好一个简单的项目练手了成品工具下载：  to_bat.zip成果展示那就拿隐写神器Stegsolve做个例子，我一直觉得它在我的一众图标中是个扎眼的存在，拿它开个刀  运行to_bat.exe  按照提示，输入jar文件的路径，一般都是在当前目录运行，直接输入文件名就行，jdk文件直接用JAVA_HOME的地址，也就是不带bin目录的然后可以看见新建了两个文件，一个bat批处理文件，一个vbs脚本文件    bat文件运行截图  vbs文件正常打开就ok了，然后就能创建快捷方式装饰图标了  文末外话小工具使用pyq5写的，pyinstaller打包的，打包完了有点大，凑合着用。我是打算专门建个文件夹放不同版本的jdk，运行jar文件的时候直接工具填上我的jdk路径，生成vbs脚本一键启动。算是熟悉了一下gui快速开发工具"
  },
  
  {
    "title": "BuckeyeCTF-2022-writeup",
    "url": "/posts/BuckeyeCTF-2022-writeup/",
    "categories": "writeup",
    "tags": "CTF, Writeup",
    "date": "2022-11-12 00:00:00 +0800",
    





    
    "snippet": "文前漫谈  比赛地址：https://pwnoh.io/challsWebbuckeyenotes/beginner  des：Note taking apps are all the rage lately but turns our they’re harder to make than I thought :/. Even in development buckeyenotes has...",
    "content": "文前漫谈  比赛地址：https://pwnoh.io/challsWebbuckeyenotes/beginner  des：Note taking apps are all the rage lately but turns our they’re harder to make than I thought :/. Even in development buckeyenotes has gotten some traction, Brutus signed up! I think his user name is brutusB3stNut9999. I wonder what kind of notes he writes 🤔 but I don’t have his login….https://buckeyenotes.chall.pwnoh.io来看看国际友人的题目，登录界面，题目说了Brutus的用户名是brutusB3stNut9999很自然想到sql注入了，于是对比一下输入回显，发现可能真的存在注入了然后一番折腾发现了这个，意思应该是过滤了等号。那就直接1' or 1 -- -应该是已经成功查询了，然后想着限制一下查询数量看看，也是试了不少次' or 1 limit 1, 2-- -过滤了等号直接就出了View source用的是sqlite数据库代码逻辑要求sql语句中查询的结果是brutusB3stNut9999，如果是则$authenticated = true;得到flag，呜呜呜，要是有密码，直接输密码就行。索性这里只过滤了个=，我们只要limit限制查询结果就OK，也就是' or 1 limit 1, 2-- -但是不知道为什么' or 1 limit 1, 1-- -不行，这点暂时没想明白pong/beginner  des：I dug up my first ever JavaScript game, but this time, my AI is unbeatable!! Hah!https://pong.chall.pwnoh.ioA  JavaScript game，我对JavaScript的印象就是直接在响应包中找base64加密过的flag，或者是console弹一段代码得到flag，这个题目还真是涨见识了&lt;script&gt;const socket = io();const canvas = document.getElementById(\"game\");const pl = .16;const pw = .02;const bs = .04;var up = 0;var down = 0;var p1 = .5;var p2 = .5;var bx = .5;var by = .5;var bvx = 0;var bvy = 0;var spin = 0;var bt = 0;var s1 = 0;var s2 = 0;function reset(ctx) {  ctx.resetTransform();  ctx.translate(0, 0.5);  ctx.lineWidth = 1;}function set() {  bx = 0.5;  by = 0.5;  bvx = 0;  bvy = 0;  bt = 0;  spin = 0;}function draw() {  canvas.width = canvas.clientWidth;  canvas.height = canvas.clientHeight;  const w = canvas.width;  const h = canvas.height;  const ctx = canvas.getContext(\"2d\");  reset(ctx);  ctx.fillStyle = \"#FFFFFF\";  ctx.fillRect(0, 0, w, h);  // field lines  ctx.fillStyle = \"#aaaaaa\";  for(var y = 0; y &lt; 1; y += .1) {    ctx.fillRect(w / 2 - 5, (y + .025) * h, 10, .05 * h);  }  // ball  ctx.fillStyle = \"#000000\";  ctx.translate(bx * w, by * h);  bt += spin;  while(bt &lt; 0) bt += 360;  while(bt &gt; 359) bt -= 360;  ctx.rotate(bt * Math.PI / 180);  ctx.fillRect(-(bs * h) / 2, -(bs * h) / 2, bs * h, bs * h);  reset(ctx);  // paddles  ctx.fillStyle = \"#000000\";  ctx.fillRect(pw * w, (p1 - pl / 2) * h, pw * w, pl * h);  ctx.fillRect((1 - 2 * pw) * w, (p2 - pl / 2) * h, pw * w, pl * h);  // scores  for(var x = 0; x &lt; 20; x++) {    ctx.beginPath();    ctx.rect(x * .05 * w, 0, .05 * w, 0.01 * h);    ctx.stroke();    if(x &lt; s1) ctx.fillRect(x * .05 * w, 0, .05 * w, 0.01 * h);    if(x &gt; 9 &amp;&amp; s2 &gt; 19 - x) ctx.fillRect(x * .05 * w, 0, .05 * w, 0.01 * h);  }}function tick() {  const w = canvas.width;  const h = canvas.height;  // controls  if(p1 - up * .01 &gt; pl / 2) p1 -= up * .01;  if(p1 + down * .01 &lt; 1 - pl / 2) p1 += down * .01;  p2 = by;  // ball  if(bvx != 0) spin = bvy / bvx * 5;  bx += bvx;  by += bvy;  if(by &lt; 0 || by &gt; 1) bvy *= -1; // v bounce  if(bx &lt; pw * 2) {    // left paddle bounce    if(by &gt; p1 - pl / 2 &amp;&amp; by &lt; p1 + pl / 2) {      let diff = by - p1;      bvy = .015 * diff / (pl / 2);      bvx = .015 - Math.abs(bvy);    }  }  if(bx &gt; 1 - pw * 2) {    // right paddle bounce    if(by &gt; p2 - pl / 2 &amp;&amp; by &lt; p2 + pl / 2) {      let diff = by - p2;      bvy = .015 * diff / (pl / 2);      bvx = -(.015 - Math.abs(bvy));    }     }  if(bx &lt; -.1 || bx &gt; 1.1) {    socket.emit(\"score\", bx);  }  draw();}function init() {  draw();  setInterval(tick, 13);  document.addEventListener(\"keydown\", (e) =&gt; {    if(e.key == \"w\") up = 1;    if(e.key == \"s\") down = 1;    if(e.key == \"p\") {      socket.emit(\"begin\");    }  });  document.addEventListener(\"keyup\", (e) =&gt; {    if(e.key == \"w\") up = 0;    if(e.key == \"s\") down = 0;  });}socket.on(\"alert\", (msg) =&gt; alert(msg));socket.on(\"begin\", (params) =&gt; {  bvx = params.bvx;  bvy = params.bvy;});socket.on(\"set\", (scores) =&gt; {  set();  s1 = scores.sx1;  s2 = scores.sx2;});&lt;/script&gt;  Since JavaScript is a client-side language, we can use our console in the developer tool to control some variables.So 大意就是我们可以在开发者工具的控制台中控制这些变量，尽管看不太懂js，但大概能知道s1和s2是分数，而s1是我的分数，s2是对手的分数，于是可以在控制台中修改变量。但是没啥用啊。但是这样打开了思路，可以找其他变量试试，最后发现了bx这个变量，是ball在x坐标上的位置，于是我们可以自己控制球的位置最后令bx等于1.5，球就越过了对手的防线(超出了屏幕)，we win ！，就得到了flagMiscwhat-you-see-is-what-you-git/beginner  des：I definitely made a Git repo, but I somehow broke it. Something about not getting a HEAD of myself.git相关的题目，关键还是logs日志文件，HEAD中有些线索然后恢复Hid the flag提交的暂存区  git reset –hard 7ae8453a76a41d40bdfcc7992175390f70ba9fdf注解\t# 重置暂存区与工作区，与上一次commit保持一致再  git log -p [file]注解# 显示指定文件相关的每一次diff得到flagsus/easy  des：Something about this audio is pretty sus…Hint: The crackling in the audio should tell you that something’s wrong.wav的LSB隐写，参加 Medium blog!import wavesong = wave.open(\"sus.wav\", mode='rb')# Convert audio to byte arrayframe_bytes = bytearray(list(song.readframes(song.getnframes())))# Extract the LSB of each byteextracted = [frame_bytes[i] &amp; 1 for i in range(len(frame_bytes))]# Convert byte array back to stringstring = \"\".join(chr(int(\"\".join(map(str,extracted[i:i+8])),2)) for i in range(0,len(extracted),8))# Cut off at the filler charactersdecoded = string.split(\"###\")[0]# Print the extracted textprint(\"Sucessfully decoded: \"+decoded)song.close()keyboardwarrior/medium  des：I found a PCAP of some Bluetooth packets being sent on this guy’s computer. He’s sending some pretty weird stuff, you should take a look.Flag format: buckeyectf{}相对平时的蓝牙流量，是很新的题目（协议）了。HCI_EVT和ATT协议，关于协议懒得去深究了，反正和一般的键盘数据数据段相同。\t_一大堆数据中只有第三个字节不同，于是把以前写的脚本换个导出字段，改改就行https://github.com/may1as/UsbMiceDataexp那个value的过滤器字段如下，然后-e替换成btatt.value即可_但是这里还有个坑，得把_[]_换成_{}_，_-_换成___，符号不同可能是字典不一致导致的，但是这里无伤大雅一些小工具file command for windows  https://gnuwin32.sourceforge.net/packages/file.htmresourcehttps://siunam321.github.io/ctf/BuckeyeCTF-2022/"
  },
  
  {
    "title": "如何基于volatility2构建“新”版本内核的profile",
    "url": "/posts/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Evolatility2%E6%9E%84%E5%BB%BA-%E6%96%B0-%E7%89%88%E6%9C%AC%E5%86%85%E6%A0%B8%E7%9A%84profile/",
    "categories": "内存取证, volatility",
    "tags": "内存取证",
    "date": "2022-11-04 00:00:00 +0800",
    





    
    "snippet": "  文章水在跳跳糖上了",
    "content": "  文章水在跳跳糖上了"
  },
  
  {
    "title": "2022蓝帽杯遇见的SUID提权",
    "url": "/posts/2022%E8%93%9D%E5%B8%BD%E6%9D%AF%E9%81%87%E8%A7%81%E7%9A%84-SUID-%E6%8F%90%E6%9D%83-%E5%89%AF%E6%9C%AC/",
    "categories": "提权",
    "tags": "SUID提权",
    "date": "2022-10-31 00:00:00 +0800",
    





    
    "snippet": "  文章发在跳跳糖上了",
    "content": "  文章发在跳跳糖上了"
  },
  
  {
    "title": "CTF中我的USB键盘鼠标流量解密指南和脚本",
    "url": "/posts/CTF%E4%B8%AD%E6%88%91%E7%9A%84USB%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E6%B5%81%E9%87%8F%E8%A7%A3%E5%AF%86%E6%8C%87%E5%8D%97%E5%92%8C%E8%84%9A%E6%9C%AC/",
    "categories": "流量分析, USB",
    "tags": "流量分析",
    "date": "2022-10-12 00:00:00 +0800",
    





    
    "snippet": "  文章首发于freebuf文前漫谈对ctf中的USB做一个了断吧，先摆上一些概念性的东西USB是 UniversalSerial Bus（通用串行总线）的缩写，是一个外部总线标准，用于规范电脑与外部设备的连接和通讯，例如键盘、鼠标、打印机、磁盘或网络适配器等等。通过对该接口流量的监听，我们可以得到取键盘敲击键、鼠标移动与点击、存储设备的铭文传输通信、USB无线网卡网络传输内容等等。USB的...",
    "content": "  文章首发于freebuf文前漫谈对ctf中的USB做一个了断吧，先摆上一些概念性的东西USB是 UniversalSerial Bus（通用串行总线）的缩写，是一个外部总线标准，用于规范电脑与外部设备的连接和通讯，例如键盘、鼠标、打印机、磁盘或网络适配器等等。通过对该接口流量的监听，我们可以得到取键盘敲击键、鼠标移动与点击、存储设备的铭文传输通信、USB无线网卡网络传输内容等等。USB的几种用途现在USB协议版本有USB2.0, USB3.1,USB3.2, USB4等，目前USB2.0/3.0比较常用，你在淘宝上买U盘的时候可能看见过很多“USB 3.0”。闲谈哈，你可能听过USB3.1的概念，是某苹果为了装逼提出来的，跟USB3.0差别不大，但是人家是老大哥啊，所有慢慢都向大哥看齐，都流行说USB3.1  USB UART          异步串行通信口(UART)就是我们在嵌入式中常说的串口，它还是一种通用的数据通信协议。这种方式下，设备只是简单的将 USB 用于接受和发射数据，除此之外就再没有其他通讯功能了。        USB HID（Human Interface Device）          HID（Human Interface Device，人机接口设备）是USB设备中常用的设备类型，是直接与人交互的USB设备，例如键盘、鼠标与游戏杆等。在USB设备中，HID设备的成本较低。另外，HID设备并不一定要有人机交互功能，只要符合HID类别规范的设备都是HID设备。        USB Memory          USB Memory是数据存储每一个 USB 设备（尤其是 HID 或者 Memory ）都有一个供应商 ID（Vendor ID） 和产品识别码（Product Id） 。 Vendor ID 是用来标记哪个厂商生产了这个 USB 设备。 Product ID 则用来标记不同的产品。      lsusb命令lsusb命令用于显示本机的USB设备列表，以及USB设备的详细信息。  Bus 002：指明设备连接到哪条总线Device 002：表明这是连接到总线上的第二台设备ID：设备的IDVMware, Inc. Virtual Mouse：生产商名字和设备名Tshark常用参数这里就放几个处理流量包时常用的-r:设置tshark分析的输入文件-T:设置解码结果输出的格式，包括fileds,text,ps,psml和pdml，默认为text-e:导出协议字段-Y:对应过滤器的过滤条件键盘流量以往接触到的，USB协议数据部分在Leftover Capture Data域中，数据长度为8个字节。击键信息集中在第3个字节，每次击键都会产生一个数据包。所以如果看到给出的数据包中的信息都是 8 个字节，并且只有第 3 个字节不为 0000，那么几乎可以肯定是一个键盘流量了。现在在比赛中常见的（2021国赛初赛有个例题），是这种，Leftover Capture Data——&gt;HID Data这个改变需要注意什么呢，需要注意tshark导出数据时的过滤器字段，看这个对应的过滤器字段，去wireshark的英文文档里找。tshark -r 数据包文件 -T fields -e 过滤器字段tshark -r demo.pcap -T fields -e usb.capdata这个usb.capdata就是Leftover Capture Data的field name（字段名）tshark -r demo.pcap -T fields -e usbhid.data同样的，这个usbhid.data就是HID data的field name 导出数据之后，就用python对应字典的数据写脚本解密就行，映射表是类似下面。数据部分详解：      字节下标（我还没发现这个在哪儿）              0 : 修改键(组合键)        1 : OEM 保留        2~7 : 按键码              BYTE1              bit0: Left Control 是否按下，按下为 1        bit1: Left Shift 是否按下，按下为 1        bit2: Left Alt 是否按下，按下为 1        bit3: Left WIN/GUI 是否按下，按下为 1        bit4: Right Control 是否按下，按下为 1        bit5: Right Shift 是否按下，按下为 1        bit6: Right Alt 是否按下，按下为 1        bit7: Right WIN/GUI 是否按下，按下为 1              BYTE2 - 暂不清楚，有的地方说是保留位    BYTE3-BYTE8 - 这六个为普通按键    0b10（0x02） 和 0b100000（0x20）都是按下了shift键    例如： 键盘发送 02 00 0e 00 00 00 00 00，表示同时按下了 Left Shift + ‘k’，即大写 K。具体键位对应 Universal Serial Bus HID Usage Tables - USB-IF 53页~59页我的键盘流量解密脚本https://github.com/may1as/UsbKeyboardDataexp根据wangyihang大佬的脚本改的，主要增加了个协议字段的选项放在GitHub上了，用2021国赛初赛的举个例子吧python .\\UsbKeyboardDataexp.py -f .\\example\\ez_usb.pcapng -e usbhid.data -Y \"usb.src==2.8.1\"鼠标流量鼠标流量同样，Leftover Capture Data——&gt;HID Data可能是不同版本协议导致的（我还没去考证哈，别全信）数据部分详解：与键盘击键的离散性不一样，鼠标移动时表现为连续性，不过实际上鼠标动作所产生的数据包也是离散的鼠标数据包的数据长度为4个字节。  第一个字节代表按键，当取 0x00 时，代表没有按键、为 0x01 时，代表按左键，为 0x02 时，代表当前按键为右键。  第二个字节可以看成是一个 signed byte 类型，其最高位为符号位，当这个值为正（小于127）时，代表鼠标水平右移多少像素，为负（补码负数，大于127小于255）时，代表水平左移多少像素。  第三个字节与第二字节类似，代表垂直上下移动的偏移。  第四个是扩展字节，关于滚轮的操作记录          0 - 没有滚轮运动      1 - 垂直向上滚动一下      0xFF - 垂直向下滚动一下      2 - 水平滚动右键一下      0xFE - 水平滚动左键单击一下      例如： 鼠标发送 00 01 fc 00，表示鼠标右移 01 像素，垂直向下移动 124 像素。就这么多知识，剩下的就是写脚本了我的鼠标流量解密脚本https://github.com/may1as/UsbMiceDataexp很多朋友使用wangyihang大佬的鼠标流量解密脚本，出现无法成功显示图片的问题。原因是tshark早前的版本导出数据带冒号，形如这样：00:00:04:00:00:00:00:00，而现在是00000000ffff0000，并不带冒号，导致处理数据时出现问题。 这里就处理了一下导出数据格式，增加了命令行里协议字段的选项 python .\\UsbMiceDataExp.py -f .\\example\\usb.capdata.pcapng -e usb.capdata -a LEFT参考文章#https://www.usb.org/document-library/device-class-definition-hid-111"
  },
  
  {
    "title": "My CheatSheet",
    "url": "/posts/CheatSheet/",
    "categories": "瞎折腾, CheatSheet",
    "tags": "瞎折腾",
    "date": "2022-08-10 00:00:00 +0800",
    





    
    "snippet": "正则表达式速查卡Basic Linux CommandsWebsite collectUser Agent String.Com —— 收集各种UA头Docker Errorph@ubuntu:~/Desktop$ docker-compose up -dERROR:Couldn't connect to Docker daemon at http+docker://localunixsoc...",
    "content": "正则表达式速查卡Basic Linux CommandsWebsite collectUser Agent String.Com —— 收集各种UA头Docker Errorph@ubuntu:~/Desktop$ docker-compose up -dERROR:Couldn't connect to Docker daemon at http+docker://localunixsocket - is it running?If it's at a non-standard location,specify the URL with the DOCKER_HOST environment variable.solutionsudo usermod -aG docker $USERCan not kill redis Processsolution/etc/init.d/redis-server stopLinux command Shortcutvim ~/.bashrc修改alias vol = \"python vol.py\"source ~/.bashrc不同用户之间不生效，之后在命令行中vol的效果等同于python vol.pyCommon port on network21 ftp        ftp的端口号20、21的区别一个是数据端口，一个是控制端口，控制端口一般为2169 TFTP       (简单文件传输协议) 22 SSH 23 Telnet80 web80-89 web443 https   SSL心脏滴血445 SMB     ms17-010永恒之蓝873 Rsync未授权1433 MSSQL1521 Oracle    这玩应记不住？记不住？3306 MySQL3389 远程桌面5432 PostgreSQL5900 vnc   目前常用的协议有VNC/SPICE/RDP三种 、小巧，支持客户端和服务器端的直接拷贝粘贴，缺点：速度最慢6379 redis未授权7001,7002 WebLogic默认弱口令，反序列8080 tomcat/WDCP主机管理系统，默认弱口令8080,8089,9090 JBOSSJboss通常占用的端口是1098，1099，4444，4445，8080，8009，8083，8093这几个，\t\t默认端口是8080\t\t在windows系统中：1098、1099、4444、4445、8083端口在/jboss/server/default/conf/jboss-service.xml中8080端口在/jboss/server/default/deploy/jboss-web.deployer/server.xml中8093端口在/jboss/server/default/deploy/jms/uil2-service.xml中。8000-9090 都是一些常见的web端口27017,27018 Mongodb未授权访问28017 mongodb统计页面50070,50030 hadoop默认端口未授权访问161 SNMP389 LDAP512,513,514 Rexec1025,111 NFS2082/2083 cpanel主机管理系统登陆 （国外用较多）2222 DA虚拟主机管理系统登陆 （国外用较多）2601,2604 zebra路由，默认密码zebra3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了3312/3311 kangle主机管理系统登陆4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网5984 CouchDB http://xxx:5984/_utils/6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网7778 Kloxo主机控制面板登录8083 Vestacp主机管理系统 （国外用较多）8649 ganglia8888 amh/LuManager 主机管理系统默认端口9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞10000 Virtualmin/Webmin 服务器虚拟主机管理系统11211 memcache未授权访问50000 SAP命令执行python输出终端带颜色print(\\033[显示方式;前景色;背景色m输出内容\\033[0m)            显示方式      效果                  0      默认              1      粗体              4      下划线              5      闪烁              7      反白显示                  字体色编号      背景色编号      颜色                  30      40      黑色              31      41      红色              32      42      绿色              33      43      黄色              34      44      蓝色              35      45      紫色              36      46      青色              37      47      白色      Kerberos ProtocolPython requests General Headersheaders={    'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',    'Cache-Control':'max-age=0',    'Connection':'close',    'Referer':'http://www.baidu.com/',    'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.4882.400 QQBrowser/9.7.13059.400'}Windows powershell 配置文件位置  在 Windows PowerShell 中可以有四个不同的配置文件。配置文件按加载顺序列出。较特定的配置文件优先于较不特定的配置文件（如果它们适用）。      %windir%\\system32\\WindowsPowerShell\\v1.0\\profile.ps1此配置文件适用于所有用户和所有 shell。        %windir%\\system32\\WindowsPowerShell\\v1.0\\ Microsoft.PowerShell_profile.ps1此配置文件适用于所有用户，但仅适用于 Microsoft.PowerShell shell。        %UserProfile%\\My Documents\\WindowsPowerShell\\profile.ps1此配置文件仅适用于当前用户，但会影响所有 shell。        %UserProfile%\\My Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1此配置文件仅适用于当前用户和 Microsoft.PowerShell shell。  xss get cookie"
  },
  
  {
    "title": "Python-ctf赛事通知机器人（飞书版）",
    "url": "/posts/Python-ctf%E8%B5%9B%E4%BA%8B%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%99%A8%E4%BA%BA-%E9%A3%9E%E4%B9%A6%E7%89%88/",
    "categories": "瞎折腾, 比赛通知机器人",
    "tags": "瞎折腾",
    "date": "2022-08-07 00:00:00 +0800",
    





    
    "snippet": "  用的ctfhub的接口，分两个模块，放在云服务器上定时运行  本来想美化一下赛事发布的消息，增加比赛简介什么的，没啥精力折腾了（可能也没啥人看）  有需要的话，可以整合一下ctftime的赛事通知import requestsimport re import timeimport jsonimport hashlibimport base64import hmacfrom datetim...",
    "content": "  用的ctfhub的接口，分两个模块，放在云服务器上定时运行  本来想美化一下赛事发布的消息，增加比赛简介什么的，没啥精力折腾了（可能也没啥人看）  有需要的话，可以整合一下ctftime的赛事通知import requestsimport re import timeimport jsonimport hashlibimport base64import hmacfrom datetime import datetime# 获取即将到来的比赛IDdef getupcoming_id():    upcoming_url = \"https://api.ctfhub.com/User_API/Event/getUpcoming\" #获取即将开始的比赛ID    upcoming_payload = {        'offset': 0,        'limit': 5    } #POST请求    upcoming_request = requests.post(upcoming_url, json=upcoming_payload)    upcoming_id = []    for i in range(len(upcoming_request.json()[\"data\"][\"items\"])):        upcoming_id.append(upcoming_request.json()[\"data\"][\"items\"][i][\"id\"])    return upcoming_id #返回比赛ID    # 获取正在进行的比赛IDdef getrunning_id():    running_url = \"https://api.ctfhub.com/User_API/Event/getRunning\" #获取正在进行的比赛ID    running_payload = {        'offset': 0,        'limit': 4    } #POST请求参数    running_request = requests.post(running_url, json=running_payload)    running_id = []    for i in range(len(running_request.json()[\"data\"][\"items\"])):        running_id.append(running_request.json()[\"data\"][\"items\"][i][\"id\"])    return running_id #返回比赛ID    # 通过比赛ID获取详细信息def getinfo(id):    s = ''    for i in id:        info_url = \"https://api.ctfhub.com/User_API/Event/getInfo\"  #获取详细信息的网址        info_payload = {            \"event_id\": i,        } #POST请求参数        info_request = requests.post(url=info_url, json=info_payload)        js = info_request.json() #把返回值转为json格式        s +=\"\\n\"\\        + \"📛名称：\" + \"[\" + js[\"data\"][\"title\"] + \"]\" +\"\\n\" \\        + \"🕳比赛类型：\" + js[\"data\"][\"class\"] + \"\\n\" \\        + \"🕳比赛形式：\" + js[\"data\"][\"form\"]+ \"\\n\" \\        + \"⏰开始时间：\" + time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(js[\"data\"][\"start_time\"])) + \"\\n\" \\        + \"⏰结束时间：\" + time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(js[\"data\"][\"end_time\"])) + \"\\n\" \\        + \"✅比赛链接：\" + js[\"data\"][\"official_url\"] + \"\\n\"\\        +\"\\n\"    return sdef sendtobot(zengyan,msg):    url = \"xxxxx\"    msgContent = {        \"text\": zengyan+\"\\r\\n\"+msg,    }    req = {        \"timestamp\": timestamp,        # \"sign\": gen_sign(timestamp=timestamp, secret=\"PyiPNYD2OrHj4LktOqmJMg\"),        \"msg_type\": \"text\",        \"content\": json.dumps(msgContent)       }    payload = json.dumps(req)    headers = {        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36 Edg/105.0.1343.53\",        # 'Authorization': 'Bearer xxx', # your access token        'Content-Type': 'application/json'    }    #推送通知    response = requests.request(\"POST\", url, headers=headers, data=payload)    print(response.headers['X-Tt-Logid']) # for debug or oncall    print(response.content) # Print Responseif __name__ == '__main__':    # 当前日期和时间    now = datetime.now()    timestamp = datetime.timestamp(now)    #发送到飞书    print(\"---正在进行的比赛---\")    print(getinfo(getrunning_id()))    sendtobot(zengyan = \"🚩--正在进行的比赛--🏆\",msg = getinfo(getrunning_id()))import requestsimport re import timeimport jsonfrom datetime import datetime# 获取即将到来的比赛IDdef getupcoming_id():    upcoming_url = \"https://api.ctfhub.com/User_API/Event/getUpcoming\" #获取即将开始的比赛ID    upcoming_payload = {        'offset': 0,        'limit': 3    } #POST请求    upcoming_request = requests.post(upcoming_url, json=upcoming_payload)    upcoming_id = []    for i in range(len(upcoming_request.json()[\"data\"][\"items\"])):        upcoming_id.append(upcoming_request.json()[\"data\"][\"items\"][i][\"id\"])    return upcoming_id #返回比赛ID# 通过比赛ID获取详细信息def getinfo(id):    s = ''    for i in id:        info_url = \"https://api.ctfhub.com/User_API/Event/getInfo\"  #获取详细信息的网址        info_payload = {            \"event_id\": i,        } #POST请求参数        info_request = requests.post(url=info_url, json=info_payload)        js = info_request.json() #把返回值转为json格式        s +=\"\\n\"\\             + \"📛名称：\" + js[\"data\"][\"title\"] + \"\\n\" \\             + \"🕳比赛类型：\" + js[\"data\"][\"class\"] + \"\\n\" \\             + \"🕳比赛形式：\" + js[\"data\"][\"form\"]+ \"\\n\" \\             + \"⏰开始时间：\" + time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(js[\"data\"][\"start_time\"])) + \"\\n\" \\             + \"⏰结束时间：\" + time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(js[\"data\"][\"end_time\"])) + \"\\n\" \\             + \"✅比赛链接：\" + js[\"data\"][\"official_url\"] + \"\\n\"\\            +\"\\n\"    return sdef sendtobot(zengyan,msg):    url = \"xxxxxxxx\"    msgContent = {        \"text\": zengyan+\"\\r\\n\"+msg,    }    req = {        \"timestamp\": timestamp,        # \"sign\": gen_sign(timestamp=timestamp, secret=\"PyiPNYD2OrHj4LktOqmJMg\"),        \"msg_type\": \"text\",        \"content\": json.dumps(msgContent)       }    payload = json.dumps(req)    headers = {        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36 Edg/105.0.1343.53\",        # 'Authorization': 'Bearer xxx', # your access token        'Content-Type': 'application/json'    }    #推送通知    response = requests.request(\"POST\", url, headers=headers, data=payload)    print(response.headers['X-Tt-Logid']) # for debug or oncall    print(response.content) # Print Responseif __name__ == '__main__':    # 当前日期和时间    now = datetime.now()    timestamp = datetime.timestamp(now)    #发送到飞书    print(\"🚩--即将到来的比赛--🏆\")    print(getinfo(getupcoming_id()))    sendtobot(zengyan = \"🚩--即将到来的比赛--🏆\",msg = getinfo(getupcoming_id()))"
  },
  
  {
    "title": "My Life",
    "url": "/posts/Mylife/",
    "categories": "瞎折腾, Life",
    "tags": "瞎折腾",
    "date": "2022-08-01 00:00:00 +0800",
    





    
    "snippet": "一些生活里的碎片For me , may For you没有人永远emo，但永远有人正emo着—— 致暗恋的青春  于 2023.1.7 (用了YouTube misic后少有的打开网易云)找了个实习，想想脑子里还是空空，还是等暑假或者大三吧                                                                            ...",
    "content": "一些生活里的碎片For me , may For you没有人永远emo，但永远有人正emo着—— 致暗恋的青春  于 2023.1.7 (用了YouTube misic后少有的打开网易云)找了个实习，想想脑子里还是空空，还是等暑假或者大三吧                                                                               烫了个tou，括弧锡纸烫，但是还没想当渣男哈哈  于 2023.1.9 (记录一下，这眼睛还是一单一双，显得一大一小的，哈哈)很少去影院看电影，可能实在没有这个习惯，也总赶不上趟，趁不到一个恰好的时间去看一部感兴趣的电影。所以我总是一个人窝着，恰好有兴趣的时候，看一部可能已经过时的，但是我还挺喜欢的电影。《四海》是韩寒的作品，看到一半，脑子里总是浮现《左耳》的场景，觉得画面像，色彩像。看见周欢颂骑着“想办法”赎回来的摩托车，在去赴约的路上，最后的镜头也只给了摩托车，《左耳》浮现的更深了，觉得故事像，给我的情绪像。好像故事只能是遗憾的，就算是电影，就算是另类的韩寒。我不喜欢这样的结局，甚至说的是厌恶。其实我挺感兴趣的是，这样的人生是否真的属于某些人呢，未来会不会再遇见这样人生的朋友。小渔村、小镇、小岛，我喜欢这种见面都是熟人的不大不小。如果一个慢热的人，出生在这样的不大不小，决定在那儿生活，遇见一个周欢颂，开家海上的鱼排小餐馆，一天一天的过，也很好。  于 2022.12.8 (22:48 看完《四海》)好像…..十七八岁的两三年抵不过二十三四的两三天趴着的是老表，我在躺着  于 2023.1.26 (和表哥们喝了三四两白酒，第一次喝这么多白的)突然想起来高中毕业那会儿的一时兴起，注册的中国诗歌网的账号，甚至混上了“蓝V诗人”，听说挺水的。当时为了混500稿费，搜肠刮肚出来的诗。还有两个长辈点赞，这上面的人都是实打实的叔姨们，不过也都是老一辈的人了这个缘起是一个小学时候玩的挺好的女生突然又找到了我，只是后来又走近了一段时间就又淡了。有意思的是我现在还记得她家的车牌号，小时候的点真是很奇怪啊。这可还是我的粉丝，记得还有个南大的教授也关注我了，迄今为止我也只写了那一首，：）和张继一样有个阿姨搁我主页的评论，记得当时我的签名是“ 生而倜傥，博学能文，滑稽多智，蕴藉风流，何时为一时之冠。”东方吹破少年梦，好像也算不得是个梦……  于 2023.02.04 (开学考抢学img)前两天水的CNVD过了可惜，事件型好像没有证书，哈哈  于 2023.02.09(看了以前拿不下的站)算是了了高中的一个遗憾吧，let it go then 朝前看  于 2023.02.10 晚 至 很晚又水一个，有听说两个事件型高危好像都有证书，这个也是我以前拿不下的一个站感觉有时候运气真的很重要，学习阶段的话，碰见暂时拿不下的，记录下来，以后再看  于 2023.02.15 (考离散的前一天)"
  },
  
  {
    "title": "pythonweb SSTI的payload构造思路研究(基础篇)",
    "url": "/posts/pythonweb-SSTI%E7%9A%84payload%E6%9E%84%E9%80%A0%E6%80%9D%E8%B7%AF%E7%A0%94%E7%A9%B6-%E5%9F%BA%E7%A1%80%E7%AF%87/",
    "categories": "PythonSEC, SSTI",
    "tags": "PythonSSTI",
    "date": "2022-07-24 00:00:00 +0800",
    





    
    "snippet": "  在freebuf上发过，这里的是精简入门版文前漫谈是一篇基础篇嘛，给新同学入门用，从payload的角度看看SSTI从原点出发你会发现，大多数payload总是从下面这段代码出发，延伸出各种各样的花样。而这一步的目的是得到当前模块中所有可以利用的类。得到的结果跟当前模块（py文件）import的库也是有关系的。''.__class__.__base__.__subclasses__()详...",
    "content": "  在freebuf上发过，这里的是精简入门版文前漫谈是一篇基础篇嘛，给新同学入门用，从payload的角度看看SSTI从原点出发你会发现，大多数payload总是从下面这段代码出发，延伸出各种各样的花样。而这一步的目的是得到当前模块中所有可以利用的类。得到的结果跟当前模块（py文件）import的库也是有关系的。''.__class__.__base__.__subclasses__()详细解释：  ''，是一个字符串对象，type('')的结果是&lt;class 'str'&gt;，在python中，一切皆对象，再比如type([])的结果是&lt;class 'list'&gt;，因为[]是数组的标志  __class__，是这个对象所属的类，到这一步，''.__class__的结果仍然是&lt;class 'str'&gt;''.__class__和''，区别在于前者是个类，后者是个对象  __base__，是获得指定类的基类（父类），这里''.__class__.__base__的结果是&lt;class 'object'&gt;，因为在python3中，所有类都默认继承了Object类。  __subclasses__() ，__subclasses__()是Object类的静态方法，获得指定类的所有子类，返回一个列表。因为是个方法，所以后面的括号不能忘了带。在这个列表里，拿到了所有继承Object类的子类，而在python3里，几乎所有的内建类都继承了Object类，所以在下一步的构造中几乎所有的内置类我们都能找到并利用。拿一个Payload研究尝试直接在代码中（最好在flask环境下）print(\"\".__class__.__base__.__subclasses__()[128].__init__.__globals__['popen']('whoami').read())。是不是成功执行\"whoami\"了。也有可能你那报错了。比如，这是因为你从''.__class__.__base__.__subclasses__()这一步拿到的子类列表，索引为128的类对应的不是os._wrap_close类，因为从这一步我们没有进入os模块所在的地址空间，就不能通过__globals__得到os模块已经加载的可利用类  补充一下 __globals__Python 中的每一个函数都拥有一个 globals 属性，储存着当前模块全局可读的量。以一个字典的形式，建立了一种映射的关系。它必须由一个函数方法调用，即不论是test.globals，还是a.globals。只要是在一个模块（同一个py文件）内结果都是一样，因为打印的都是全局可读的量。#payload = \"\".__class__.__base__.__subclasses__()[128].__init__.__globals__['popen']('whoami').read()a= \"\"b= \"\".__class__c= \"\".__class__.__base__d= \"\".__class__.__base__.__subclasses__()e= \"\".__class__.__base__.__subclasses__()[128]f= \"\".__class__.__base__.__subclasses__()[128].__init__g= \"\".__class__.__base__.__subclasses__()[128].__init__.__globals__h= \"\".__class__.__base__.__subclasses__()[128].__init__.__globals__['popen']('whoami')i= \"\".__class__.__base__.__subclasses__()[128].__init__.__globals__['popen']('whoami').read()print(a,b,c,d,e,f,g,h,i)按照上面的字母开始介绍吧。a到d在前面已经介绍过。这里从e开始。  e=\"\".__class__.__base__.__subclasses__()[128]e=\"\".__class__.__base__.__subclasses__()[128]的结果是&lt;class 'os._wrap_close'&gt;，所以你应当了解，使用这个payload的时候，这个128是特殊的，它得跟随着os._wrap_close类的位置变化（从零开始数，第129个是os._wrap_close类），这个payload也正是利用的os._wrap_close这个类。到这一步，\"\".__class__.__base__.__subclasses__()[128]其实就相当于os._wrap_close这个类了。  f=\"\".__class__.__base__.__subclasses__()[128].__init__  g= \"\".__class__.__base__.__subclasses__()[128].__init__.__globals__这一段的依据主要是前面的__globals__属性了，为什么要先调用__init__，因为__globals__必须依靠方法才能调用，打印全局可读的量。从上面的截图看，这一步就得到os模块全局可读的量了。注意是os模块，不是其他模块。从下面截图里的一些细节不能看出，比如'__name__': 'os'，可以看见所处模块的名称。分析一下这一步的结果。这一步得到是一个字典，像下面这样'_unsetenv': &lt;function &lt;lambda&gt; at 0x0000021A10612438&gt;, 'getenv': &lt;function getenv at 0x0000021A106129D8&gt;大概就是一种映射关系，函数名与所在地址空间的映射，你可以尝试用keys()，打印键试试你看，可以利用的函数是太多了。这里我们利用的是'popen()'这个函数，但是只要是在上面的函数，都可以利用，system()，甚至一些os库的常见函数，都能进行调用。举个例子，调用上面框出来的os这个库的system()函数，甚至更加简单。一些读，写的操作都可以借助os这个库实现。文末补充前面说过''.__class__.__base__.__subclasses__()得到的继承Object类的一个列表，数量与import的库有关。再谈谈吧不导包的时候，或者导python内置模块的时候。它的数量不会变化，导入一个外置包的时候，继承Object类的子类就变多了。好在这里不会影响到我们内置类的顺序，拿这个payload来说\"\".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen']('whoami').read()，如果第129（从零开始）个不是os._wrap_close类，那接下来的使用就会发生错误。你可以替换成129输出试试。但是在有些题目环境中，重启环境可能会影响拿到类的顺序的。这也是你直接使用别人payload打不通的原因"
  },
  
  {
    "title": "内存取证 vol2-plugins-for-Window",
    "url": "/posts/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81-vol2-plugins-for-Windows/",
    "categories": "内存取证, vol2",
    "tags": "内存取证",
    "date": "2022-07-12 00:00:00 +0800",
    





    
    "snippet": "文前漫谈vol2的关于windows的常用命令GitHub项目地址：https://github.com/volatilityfoundation/volatility官方网站：https://www.volatilityfoundation.org/命令格式命令格式非常简单，多用两次就记住了python2/3 vol.py -f [image] --profile=[profile] [p...",
    "content": "文前漫谈vol2的关于windows的常用命令GitHub项目地址：https://github.com/volatilityfoundation/volatility官方网站：https://www.volatilityfoundation.org/命令格式命令格式非常简单，多用两次就记住了python2/3 vol.py -f [image] --profile=[profile] [plugin]用python2/3具体看你下载的版本image：要取证的内存镜像profile：内存镜像所属系统plugin：要使用的插件查看vol配置插件这里的vol.exe是windows下的，在官网下载，主要是命令行参数--info，查看vol的一些配置信息，和已经安装的插件一切从获取镜像信息开始这个命令格式还是很简单的，imageinfo，这也是个插件，判断该镜像的架构，下面所以操作都基于这一步。vol.py -f .\\OtterCTF.vmem imageinfo-f 指定文件下面的Suggested Profile(s)，探测出多个可能的系统信息，可靠性从前往后排序，一般取第一个，知道系统后，在--profile=中带上对应的系统架构，继续后面的分析。另外，获取系统还有kdbgscan这个插件，和imageinfo的效果一样插件使用基础使用还是很简单的，入门已经完成，接下来进入简单进阶了。主要关注插件的使用就行了。查看计算机名称在注册表SYSTEM里面存在计算机名称具体位置：ControlSet001\\Control\\ComputerName\\ComputerName我们可以使用命令：vol.py -f [image] --profile=[profile] printkey -K \"ControlSet001\\Control\\ComputerName\\ComputerName\"查看系统用户名vol.py -f [image] --profile=[profile] printkey -K \"SAM\\Domains\\Account\\Users\\Names\"查看注册表信息vol.py -f [image] --profile=[profile] printkey -K \"xxxxxxx\"-K：\"键值\"###查找⽤户名密码信息hashdump，从 SYSTEM 和 SAM 注册表配置单元中转储 NTLM 哈希这个在很多比赛很常用，密码都是经过hash的，拿去md5解密就行，比如，画红框的那行就是用户Rick经过hash的密码。vol.py -f [image] --profile=[profile] hashdump有的出题人可能比较善良，专门找个“解”不了的hash给你，这时候我们可以尝试使用 John the Ripper 或 Hashcat（或 Google）等工具来破解它，或者我们可以尝试使用_lsadump_插件从LSA secrets中提取明文密码vol.py -f [image] --profile=[profile] lsadump并不适合所有的例子，有一定失败率，下面是个成功的例子，MortyIsReallyAnOtter查看系统进程信息            查看进程列表      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 pslist                  查看进程列表（树形）      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 pstree              查看进程列表(psx视图)      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 psxview              查看进程列表                     psscan 可以找到先前已终止（不活动）的进程以及被rootkit隐藏或解链的进程,pslist和pstree无法检测隐藏或解链的进程      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 psscan      查看网络进程vol.py -f [image] --profile=[profile] netscan查看内存中剪贴板的内容vol3中好像还没这个功能vol.py -f [image] --profile=[profile] clipboard查看内存中的截图vol.py -f [image] --profile=[profile] screenshot --dump-dir=./--dump-dir：导出目录，等同于-D查看cmd命令行历史vol.py -f [image] --profile=[profile] cmdline -p [进程号]-p 选项可选查看内存中的文件vol.py -f [image] --profile=[profile] filescan这个命令在linux下通常结合grep命令使用，过滤得到有用信息，例如grep \"doc\\|docx\\|rtf\"导出内存中的文件这个可能比较麻烦vol.py -f [image] --profile=[profile] dumpfiles -Q 0x000000007f142f20 -D ./-Q：根据filescan得到的参数，就是下图箭头指向-D：导出文件夹 ， ./是当前文件夹其他常用插件            查看加载的动态链接库      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 dlllist                  查看SSDT表      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 ssdt              查看UserAssist痕迹      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 userassist              查看ShimCache痕迹      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 shimcache              查看ShellBags      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 shellbags              查看服务列表      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 svcscan              查看Windows帐户hash      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 hashdump              查看最后关机时间      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 shutdowntime              查看IE历史记录      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 iehistory              提取注册表数据      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 dumpregistry              解析MFT记录      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 mftparser              导出MFT记录,恢复文件      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 mftparser –output-file=mftverbose.txt -D mftoutput              获取TrueCrypt密钥信息      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 truecryptmaster              获取TrueCrypt密码信息      Vol.exe -f Win7_SP1_x86.vmem –profile=Win7SP1x86 truecryptpassphras      "
  }
  
]

